<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta http-equiv="Cache-Control" content="no-siteapp">
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=1, minimum-scale=1, maximum-scale=1">
<meta name="renderer" content="webkit">
<meta name="google" value="notranslate">
<meta name="robots" content="index,follow">


<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="钟俊的博客">
<meta name="twitter:description" content="记录">
<meta name="twitter:image:src" content="http://www.daqu.github.io/images/avatar.jpg">

<meta property="og:url" content="http://www.daqu.github.io">
<meta property="og:title" content="钟俊的博客">
<meta property="og:description" content="记录">
<meta property="og:site_name" content="钟俊的博客">
<meta property="og:image" content="http://www.daqu.github.io/images/avatar.jpg">
<meta property="og:type" content="website">
<meta name="robots" content="noodp">

<meta itemprop="name" content="钟俊的博客">
<meta itemprop="description" content="记录">
<meta itemprop="image" content="http://www.daqu.github.io/images/avatar.jpg">

<link rel="canonical" href="http://www.daqu.github.io">

<link rel="shortcut icon" href="/favicon.png">
<link rel="apple-itouch-icon" href="/favicon.png">
<link rel="stylesheet" href="/bundle/index.css">
<script type="text/javascript">
    var timeSinceLang = {
        year: '年前',
        month: '个月前',
        day: '天前',
        hour: '小时前',
        minute: '分钟前',
        second: '秒前'
    };
    var root = '';
</script>


        <meta name="keywords" content="输出,storlet,openstack,">
        <meta name="description" content="从测试看storlet的部署流程">
        <meta name="author" content="钟俊">
        <title>从测试看storlet的部署流程</title>
    </head>
    <body>
        <article class="container">
            <header class="header-wrap">
  <a class="index" href="/">
    <img class="logo" src="/images/avatar.jpg" />
    钟俊的博客
  </a>
  <ul class="menu">
      <li class="menu-item"><a href="/archive.html">归档</a></li>
      <li class="menu-item"><a href="/tag.html">标签</a></li>
      <li class="menu-item"><a href="/atom.xml">订阅</a></li>
  </ul>
</header>

            <article class="main article">
                <h1 class="title">从测试看storlet的部署流程</h1>
                <section class="info">
                    <span class="avatar" style="background-image: url(/images/avatar.jpg);"></span>
                    <a class="name" href="/about.me.html">钟俊</a>
                    
                    <span class="date" data-time="1503756000"><span class="from"></span></span>
                    
                    <span class="tags"><a class="tag" href="/tag/%e8%be%93%e5%87%ba/index.html">输出</a><a class="tag" href="/tag/storlet/index.html">storlet</a><a class="tag" href="/tag/openstack/index.html">openstack</a></span>
                </section>
                <article class="content"><h2>从测试看storlet的部署流程</h2>

<p>storlet的测试入口<code>.unittest</code>如下：</p>

<pre><code class="language-shell">#! /bin/bash

SRC_DIR=$(python -c &quot;import os; print(os.path.dirname(os.path.realpath('$0')))&quot;)	#获取当前目录绝对地址
cd ${SRC_DIR}/tests/unit	#进入测试目录
nosetests --exe -v $@	#执行测试，返回结果
rvalue=$?	#返回上次的返回值
cd -	#返回上一次工作目录

exit $rvalue
</code></pre>

<p>nosetest是一个python测试模块，它能够检测当前目录下所有的测试文件、方法并执行测试。然后我们的目的是为了理解storlet的运行流程，那么可以先找到一个一个用于测试某个storlet功能的用例，比如<code>tests/functional/java/test_compress_storlet.py</code>的部分代码如下:</p>

<pre><code class="language-python">from swiftclient import client as c
from tests.functional.java import StorletJavaFunctionalTest
import unittest


class TestCompressStorlet(StorletJavaFunctionalTest):
    def setUp(self):
        self.storlet_log = ''
        self.additional_headers = {}
        main_class = 'org.openstack.storlet.compress.CompressStorlet'
        super(TestCompressStorlet, self).setUp('CompressStorlet',
                                               'compressstorlet-1.0.jar',
                                               main_class,
                                               'input.txt')

    def test_put(self):
        headers = {'X-Run-Storlet': self.storlet_name}
        headers.update(self.additional_headers)
        querystring = &quot;action=compress&quot;

        # simply set 1KB string data to compress
        data = 'A' * 1024
        
··· ···
</code></pre>

<p>先去看一下它的父类<code>StorletJavaFunctionalTest</code>,它的代码如下：</p>

<pre><code class="language-python">import os
from tests.functional import StorletFunctionalTest, PATH_TO_STORLETS

BIN_DIR = 'bin'


class StorletJavaFunctionalTest(StorletFunctionalTest):
    def setUp(self, storlet_dir, storlet_name, storlet_main,
              storlet_file, dep_names=None, headers=None):
        storlet_dir = os.path.join('java', storlet_dir)
        path_to_bundle = os.path.join(PATH_TO_STORLETS, storlet_dir,
                                      BIN_DIR)
        super(StorletJavaFunctionalTest, self).setUp('Java',
                                                     path_to_bundle,
                                                     storlet_dir,
                                                     storlet_name,
                                                     storlet_main,
                                                     storlet_file,
                                                     dep_names,
                                                     headers)
</code></pre>

<p>可以看到它的逻辑很简单，只是在语言选项那里换成了java，想必另外一个用python写的storlet也是类似。再看它的父类<code>StorletFunctionalTest</code>:</p>

<pre><code class="language-python">import unittest
import uuid

from swiftclient import client as swiftclient
from storlets.tools.cluster_config_parser import ClusterConfig
from storlets.tools.utils import deploy_storlet, get_admin_auth, put_local_file
import os

CONFIG_DIR = os.environ.get('CLUSTER_CONF_DIR', os.getcwd())
CONFIG_FILE = os.path.join(CONFIG_DIR, 'cluster_config.json')
PATH_TO_STORLETS = os.environ.get(
    'STORLET_SAMPLE_PATH',
    # assuming, current working dir is at top of storlet repo
    os.path.join(os.getcwd(), 'StorletSamples'))
CONSOLE_TIMEOUT = 2


class StorletBaseFunctionalTest(unittest.TestCase):
    def setUp(self):
        self.conf_file = CONFIG_FILE
        try:
            self.conf = ClusterConfig(CONFIG_FILE)
        except IOError:
            self.fail('cluster_config.json not found in %s. '
                      'Please check your testing environment.' % CONFIG_DIR)

        self.url, self.token = get_admin_auth(self.conf)
        # TODO(kota_): do we need to call setUp() when inheriting TestCase
        # directly? AFAIK, no setUp method in the class...
        super(StorletBaseFunctionalTest, self).setUp()


class StorletFunctionalTest(StorletBaseFunctionalTest):

    def create_container(self, container):
        response = dict()
        swiftclient.put_container(self.url, self.token,
                                  container, headers=None,
                                  response_dict=response)
        status = response.get('status')
        assert (status &gt;= 200 or status &lt; 300)

    def cleanup_container(self, container):
        # list all objects inside the container
        _, objects = swiftclient.get_container(
            self.url, self.token, container, full_listing=True)

        # delete all objects inside the container
        # N.B. this cleanup could run in parallel but currently we have a few
        # objects in the user testing container so that, currently this does
        # as sequential simply
        for obj_dict in objects:
            swiftclient.delete_object(
                self.url, self.token, container, obj_dict['name'])
        swiftclient.get_container(self.url, self.token, container)

        # delete the container
        swiftclient.delete_container(self.url, self.token, container)

    def setUp(self, language, path_to_bundle,
              storlet_dir,
              storlet_name, storlet_main, storlet_file,
              dep_names, headers):
        super(StorletFunctionalTest, self).setUp()
        self.storlet_dir = storlet_dir
        self.storlet_name = storlet_name
        self.storlet_main = storlet_main
        self.dep_names = dep_names
        self.path_to_bundle = path_to_bundle
        self.container = 'container-%s' % uuid.uuid4()
        self.storlet_file = storlet_file
        self.headers = headers or {}
        self.acct = self.url.split('/')[4]
        self.deps = []
        if dep_names:
            for d in self.dep_names:
                self.deps.append('%s/%s' % (self.path_to_bundle, d))
        storlet = '%s/%s' % (self.path_to_bundle, self.storlet_name)

        deploy_storlet(self.url, self.token,
                       storlet, self.storlet_main,
                       self.deps, language)

        self.create_container(self.container)
        if self.storlet_file:
            put_local_file(self.url, self.token,
                           self.container,
                           self.path_to_bundle,
                           self.storlet_file,
                           self.headers)

    def tearDown(self):
        self.cleanup_container(self.container)

</code></pre>

<p>可以看到这个类是我们想找的类，它封装了storlet的部署流程。下面就来分析一下这个类。</p>

<p>他首先定义了一些依赖，比如docker和编译好的storlet(在这里是jar,python那边有所不同)。先看一下docker的配置文件<code>cluster_config.json</code>。我的配置文件如下：</p>

<pre><code class="language-json">{
    &quot;groups&quot; : {
        &quot;storlet-mgmt&quot;: [&quot;127.0.0.1&quot;],
        &quot;storlet-proxy&quot;: [&quot;127.0.0.1&quot;],
        &quot;storlet-storage&quot;: [&quot;127.0.0.1&quot;],
        &quot;docker&quot;: [&quot;127.0.0.1&quot;]
    },
    &quot;all&quot; : {
        &quot;ansible_ssh_user&quot; : &quot;daqu&quot;,
        &quot;docker_device&quot;: &quot;/home/docker_device&quot;,
        &quot;storlet_source_dir&quot;: &quot;~/storlets/&quot;,
        &quot;python_dist_packages_dir&quot;: &quot;usr/local/lib/python2.7/dist-packages&quot;,
        &quot;storlet_gateway_conf_file&quot;: &quot;/etc/swift/storlet_docker_gateway.conf&quot;,
        &quot;keystone_endpoint_host&quot;: &quot;127.0.0.1&quot;,
        &quot;keystone_public_url&quot;: &quot;http://127.0.0.1/identity/v3&quot;,
        &quot;keystone_admin_url&quot;: &quot;http://127.0.0.1/identity_admin&quot;,
        &quot;keystone_admin_password&quot;: &quot;admin&quot;,
        &quot;keystone_admin_user&quot;: &quot;admin&quot;,
        &quot;keystone_admin_project&quot;: &quot;admin&quot;,
        &quot;keystone_default_domain&quot;: &quot;default&quot;,
        &quot;keystone_auth_version&quot;: &quot;3&quot;,
        &quot;swift_endpoint_host&quot;: &quot;127.0.0.1&quot;,
        &quot;swift_run_time_user&quot; : &quot;daqu&quot;,
        &quot;swift_run_time_group&quot; : &quot;daqu&quot;,
        &quot;swift_run_time_dir&quot;: &quot;/opt/stack/data/swift/run&quot;,
        &quot;storlets_management_user&quot;: &quot;daqu&quot;,
        &quot;storlet_management_account&quot;: &quot;storlet_management&quot;,
        &quot;storlet_management_admin_username&quot;: &quot;storlet_manager&quot;,
        &quot;storlet_manager_admin_password&quot;: &quot;storlet_manager&quot;,
        &quot;storlet_management_swift_topology_container&quot;: &quot;swift_cluster&quot;,
        &quot;storlet_management_swift_topology_object&quot;: &quot;cluster_config.json&quot;,
        &quot;storlet_management_ansible_dir&quot;: &quot;/opt/ibm/ansible/playbook&quot;,
        &quot;storlet_management_install_dir&quot;: &quot;/opt/ibm&quot;,
        &quot;storlets_enabled_attribute_name&quot;: &quot;storlet-enabled&quot;,
        &quot;docker_registry_random_string&quot;: &quot;ABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJ1234&quot;,
        &quot;docker_registry_port&quot;: &quot;5001&quot;,
        &quot;container_install_dir&quot;: &quot;/opt/storlets&quot;,
        &quot;storlets_default_project_name&quot;: &quot;test&quot;,
        &quot;storlets_default_project_user_name&quot;: &quot;tester&quot;,
        &quot;storlets_default_project_user_password&quot;: &quot;testing&quot;,
        &quot;storlets_default_project_member_user&quot; : &quot;tester_member&quot;,
        &quot;storlets_default_project_member_password&quot; : &quot;member&quot;,
        &quot;base_image_maintainer&quot;: &quot;root&quot;,
        &quot;base_os_image&quot;: &quot;ubuntu_16.04&quot;,
        &quot;storlets_image_name_suffix&quot;: &quot;ubuntu_16.04_jre8_storlets&quot;,
        &quot;swift_user_id&quot;: &quot;1003&quot;,
        &quot;swift_group_id&quot;: &quot;1003&quot;,
        &quot;storlet_middleware&quot;: &quot;storlet_handler&quot;,
        &quot;storlet_container&quot;: &quot;storlet&quot;,
        &quot;storlet_dependency&quot;: &quot;dependency&quot;,
        &quot;storlet_log&quot;: &quot;storletlog&quot;,
        &quot;storlet_images&quot;: &quot;docker_images&quot;,
        &quot;storlet_timeout&quot;: &quot;40&quot;,
        &quot;storlet_gateway_module&quot;: &quot;docker&quot;,
        &quot;storlet_execute_on_proxy_only&quot;: &quot;false&quot;,
        &quot;restart_linux_container_timeout&quot;: &quot;3&quot;
    }
}
</code></pre>

<p>从上面可以看出，这个配置文件主要是设置docker中的storlet。</p>

<p>然后便是编译好的storlet jar包。这个需要手动复制到<code>functional</code>目录下，否则测试会报错。</p>

<p>接下来便是<code>StorletBaseFunctionalTest</code>，它先在读取docker配置文件，再通过get_admin_auth方法获取swift认证，事实上这个方法只是对swiftclient.get_auth方法进行了进一步的封装。然后这个类就结束了。它的功能很简单，读取配置和向swift发起认证请求。在这里值得一提的是get_admin_auth方法被定义在<code>storlets/tools/utils.py</code>中，这个模块还定义了如何上传一个storlet的过程。作者先是定义了一个将本地文件上传到swift的方法<code>put_local_file</code>，然后在定义一个方法<code>put_storlet_object</code>来调用前者上传storlet。在第二个方法中，作者指定了storlet上传的容器是storlet，并且在请求元数据中加入了和storlet相关的部分，比如：</p>

<pre><code class="language-html">'X-Object-Meta-Storlet-Language': language,
'X-Object-Meta-Storlet-Interface-Version': '1.0',
'X-Object-Meta-Storlet-Object-Metadata': 'no',
'X-Object-Meta-Storlet-Main': storlet_main_class
</code></pre>

<p>此外，还有一个方法<code>put_storlet_executable_dependencies</code>，它的作用和<code>put_storlet_object</code>类似，但是它上传的是依赖，上传的容器是dependency。</p>

<p>当一个storlet和它的依赖都被上传时，这个storlet就算部署成功了。</p>

<pre><code class="language-python">def deploy_storlet(url, token, storlet, storlet_main_class, dependencies,
                   language='Java'):
    &quot;&quot;&quot;
    Deploy storlet file and required dependencies as swift objects

    :param url: swift endpoint url
    :param token: token string to access swift
    :param storlet: storlet file to be registerd
    :param dependencies: a list of dependency files to be registered
    :param language: storlet language. default value is Java
    &quot;&quot;&quot;
    # No need to create containers every time
    # put_storlet_containers(url, token)
    put_storlet_object(url, token, storlet,
                       ','.join(os.path.basename(x) for x in dependencies),
                       storlet_main_class, language)

    put_storlet_executable_dependencies(url, token, dependencies)
</code></pre>

<p>然后是<code>StorletFunctionalTest(StorletBaseFunctionalTest)</code>，这个类其实是对刚才介绍的util模块的一次应用。在这个模块对这些方法又进行了封装。</p>

<p>至此，整个storlet的溯源流程就结束了。总结一下：</p>

<ul>
<li>strolet的类结构从上到下为：

<ul>
<li>unittest.TestCase</li>
<li>StorletFunctionalTest</li>
<li>StorletJavaFunctionalTest(StorletPythonFunctionalTest)</li>
<li>TestCompressStorlet(实际的storlet)</li>
</ul></li>
<li>每一层的类都是对storlet/util.py中操作的进一步封装</li>
<li>storlet/util中定义部署storlet的方法</li>
</ul>
</article>
                <section class="author">
                    <div class="avatar" style="background-image: url(/images/avatar.jpg);"></div>
                    <a class="name" href="/about.me.html">钟俊</a>
                    <div class="intro">没有介绍</div>
                </section>
                <section class="recommend">
                    
                    <section class="nav prev more">
                        <div class="head">上篇文章</div>
                        <a class="link" href="/misc/2017/08/26/sds%e5%8e%9f%e5%9e%8b%28%e4%b8%80%29.html">SDS原型（一）</a>
                    </section>
                    
                    
                    <section class="nav next more">
                        <div class="head">下篇文章</div>
                        <a class="link" href="/misc/2017/08/26/sds%e5%8e%9f%e5%9e%8b%28%e4%ba%8c%29.html">SDS原型（二）</a>
                    </section>
                    
                </section>
                
    <section id="disqus_thread"></section>
    <script type="text/javascript">
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//username.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>


            </article>
        </article>
        <footer class="footer">
    <span class="copyright">
        钟俊的博客 ©
        <script type="text/javascript">
            document.write(new Date().getFullYear());
        </script>
    </span>
    <span class="publish">Powered by <a href="http://www.chole.io/" target="_blank">Ink</a></span>
</footer>

        <script src="/bundle/index.js"></script>
    </body>
</html>
