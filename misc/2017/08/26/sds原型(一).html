<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta http-equiv="Cache-Control" content="no-siteapp">
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=1, minimum-scale=1, maximum-scale=1">
<meta name="renderer" content="webkit">
<meta name="google" value="notranslate">
<meta name="robots" content="index,follow">


<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="钟俊的博客">
<meta name="twitter:description" content="记录">
<meta name="twitter:image:src" content="http://www.daqu.github.io/images/avatar.jpg">

<meta property="og:url" content="http://www.daqu.github.io">
<meta property="og:title" content="钟俊的博客">
<meta property="og:description" content="记录">
<meta property="og:site_name" content="钟俊的博客">
<meta property="og:image" content="http://www.daqu.github.io/images/avatar.jpg">
<meta property="og:type" content="website">
<meta name="robots" content="noodp">

<meta itemprop="name" content="钟俊的博客">
<meta itemprop="description" content="记录">
<meta itemprop="image" content="http://www.daqu.github.io/images/avatar.jpg">

<link rel="canonical" href="http://www.daqu.github.io">

<link rel="shortcut icon" href="/favicon.png">
<link rel="apple-itouch-icon" href="/favicon.png">
<link rel="stylesheet" href="/bundle/index.css">
<script type="text/javascript">
    var timeSinceLang = {
        year: '年前',
        month: '个月前',
        day: '天前',
        hour: '小时前',
        minute: '分钟前',
        second: '秒前'
    };
    var root = '';
</script>


        <meta name="keywords" content="输出,sds,">
        <meta name="description" content="SDS原型（一）">
        <meta name="author" content="钟俊">
        <title>SDS原型（一）</title>
    </head>
    <body>
        <article class="container">
            <header class="header-wrap">
  <a class="index" href="/">
    <img class="logo" src="/images/avatar.jpg" />
    钟俊的博客
  </a>
  <ul class="menu">
      <li class="menu-item"><a href="/archive.html">归档</a></li>
      <li class="menu-item"><a href="/tag.html">标签</a></li>
      <li class="menu-item"><a href="/atom.xml">订阅</a></li>
  </ul>
</header>

            <article class="main article">
                <h1 class="title">SDS原型（一）</h1>
                <section class="info">
                    <span class="avatar" style="background-image: url(/images/avatar.jpg);"></span>
                    <a class="name" href="/about.me.html">钟俊</a>
                    
                    <span class="date" data-time="1503756000"><span class="from"></span></span>
                    
                    <span class="tags"><a class="tag" href="/tag/%e8%be%93%e5%87%ba/index.html">输出</a><a class="tag" href="/tag/sds/index.html">sds</a></span>
                </section>
                <article class="content"><h1>SDS原型(一)</h1>

<p>什么是软件定义存储？目前有两种实践，基于基础设施的SDS和基于管理的SDS。个人目前倾向于后者</p>

<h2>什么是基于基础设施的SDS</h2>

<p>基于基础设施的SDS指的是，用软件定义的观念就IAAS（基础设施即服务）进行实践。举个例子，很久以前，小王所在的团队负责该公司的运维工作。由于业务需要，小王经常需要给技术人员配置服务器资源。</p>

<p>一开始，小王基本都是手动配置。但是随着任务的增多，小王负责的任务也越来越多。这时他感觉承受不了，因此他要思考怎么样才能应付这种变化。通过仔细分析他发现，每一次配置都在相同的工作，将空闲的服务器IP找出来，检查这个服务器的性能是否满足要求，将密钥和ip发给申请人。每次都做相同的步骤实在是太烦了，因此小王做了一个网站。他每次只需要在网站上点击查找，网站后台便会自动查找一个空闲的服务器，并自动将密钥和ip发给申请者。小王花了一个星期做完这个网站后，果然极大地解放了他。</p>

<p>随着公司的发展，技术人员越来越多，申请服务器资源的人也越来越多。服务器不够用啦！小王向领导申请购置新的服务器，领导说没这么多钱，但还是批了一笔预算，说：公司就只能给这么多啦。小王拿着钱发愁，心想：这点钱怎么够啊？连一台服务器都买不了。正在小王发愁的时候，vmware的销售人员找到他说：老哥，你不是说服务器不够用嘛？小弟这里有一个虚拟机软件，可以在一台机子上模拟好多台机子。不仅如此，公司专门为服务器定制了更好的产品。老哥试试不，要是觉得好，给你打个八折！小王一试，喜出望外。心想：是啊，公司的服务器性能不错，给一个人或许有点浪费，领导给的钱虽然买不起服务器，但是买这个软件还是可以的。在购买了软件之后，小王解决让更多人使用服务器的问题，领导对他表示了赞赏。</p>

<p>几年之后，公司的产品复杂度和规模越来越大。公司的服务器已经不能支撑如此高的负荷。因此小王的团队将公司的机房升级成数据中心，并且升级了虚拟机管理软件，让其支持分布式架构。这样，无论产品的规模有多大，运维这边只需要增加服务器和机房就可以啦。但是渐渐地，通过分析小王发现。产品规模增大对服务器只有存储扩容的需求。也就是说每次扩容增加的CPU、内存等其实都是没必要的。小王就发愁了，这时候他忽然发现了ceph和hdfs。小王一拍大腿，原来存储也可以独立出来搞分布式啊！很快，小王团队就完成了技术升级。将服务器的文件系统换成了分布式文件系统。这样，以后扩容的时候就能减少成本了。</p>

<p>又过了一段时间，领导觉得公司应该拓展一下业务。因此找到小王，说：小王啊，你把公司的服务器管得很好嘛。公司现在需要寻找新的利润点，我看存储就很有搞头嘛！这样吧，交给你个任务，公司打算将服务器上的一些存储资源卖出去，做个云盘、云存储什么的。你来搞个方案把。小王觉得这是个机会，便很撸起袖子打算大干一把。但是通过调研发现，潜在用户对存储的需求各不相同。小张要容量大而便宜的，小明要读取速度快而便宜的，小赵由于在国外，要求访问有保证而便宜的。似乎用户的要求除了便宜之外都各不相同。小王又发现文件系统似乎不能满足所有用户的需求。经过讨论，小王团队决定自己开发一套存储管理系统，针对可能用户做业务定制。</p>

<p>开发过程中的某一天，小王接触到了SDS。他心想：我在做的不就是SDS么，我用软件来管理存储。通过软件，存储资源可以动态分配，硬盘坏了可以自动报警。如果只是一块挂载到文件系统上的硬盘可实现不了这些功能呢。</p>

<h2>基于管理的SDS</h2>

<p>基于管理的SDS可以类比sdn，它的本质是一种架构，是一种思想。它的核心观点是控制和数据分离。从这种观点出发，有些研究者就提出。SDS应该也要践行这种观点，实现控制和数据的分离。</p>

<h3>控制</h3>

<p>在网络中，控制主要聚焦在请求发给谁、谁来执行这两个问题。那么，在存储中有没有类似的问题呢？个人认为有，但不是都有。</p>

<p>目前，存储根据接口的不同可以简单的分为块存储、对象存储、文件存储。日常接触最多的是文件存储，也就是文件系统。</p>

<p>对于文件系统来说，它开发的是posix接口，也就是write、read、list之类的函数调用接口。注意，文件系统开放的接口是函数接口。也就是说一个io请求在这种情况下生命流程并不涉及到控制，因为它只是一个调用的过程。如果要在文件系统级别上实现控制和数据分离，意味着控制层的分离或者说是搭建需要巨大的耗费。那么，在文件系统上实现SDS会不会是本末倒置，这是值得商榷的。</p>

<p>对于块存储来说，作为三者中最底层的存储。它开放的接口一般都是以内核模块或者是驱动存在的，而且它的目的在于将存储挂载。可以将文件存储理解为对块存储的进一步封装。一句话，块存储的定位让我觉得不适合在块存储这个级别实现SDS。</p>

<p>那对象存储呢？一般放在最后的就是答案。在我看来，对象存储开放的接口比较粗暴地说可以理解为就是restful的http接口。在sdn中，控制指的是请求转发的控制。但在存储中，在一次操作中三种存储能够理解成请求的只有对象存储，其它两种存储我觉得用调用来描述更加准确。也就是说，在我看来。控制和数据分离中控制是有前提的，也就是控制这个动作的主体得是和sdn中提到的请求有类似功能的个体才可以。因此，我认为对象存储在实现SDS中有独特的优势。举个例子，openstack swift存在一个中间件机制，通过中间件swift可以对上传的文件进行校验验证、名称合法性验证等操作。</p>

<h3>数据</h3>

<p>当控制和数据分离的时候，数据其实是不能按照原来的方式进行处理的。在我看来，控制和数据分离其实不仅要求控制层的独立，还对数据层有要求，也就是要进行抽象。前面提到，在网络中，控制主要聚焦在请求发给谁、谁来执行这两个问题。就这个观点来说，数据层其实就是要解决请求发给谁和谁来执行中的谁是什么的问题。就文件存储和块存储来说，这其实是一个没有必要的操作。举个例子，文件系统如果对数据进行封装，那它和对象存储有什么区别？</p>

<p>那么对于对象存储来说应该怎么解决呢？在我看来，对象存储中的存储原子也就是对象(object)已经是完备的数据层，因为它已经实现了对存储的抽象。举个例子，haystack中的小文件在存储里面都被抽象成一个needle。</p>

<h3>结论</h3>

<p>由于对象存储的架构与SDS控制和数据分离观点的匹配，我认为凡是实现了restful接口的对象存储系统都可以看成是SDS的存储系统。</p>

<h2>对象存储VS文件系统</h2>

<p>对象存储和文件系统的比较其实换一种说可以是软件定义存储相比于传统存储的优势是什么。</p>

<blockquote>
<p>在早些年，特别是2006年以前，人们提到对象存储，往往指的是以类似标准化组织SNIA定义的OSD（object storage device）和MDS（Metadata Server）为基本组成部分的分布式存储，通常是分布式文件系统。我们经常听到的分布式存储Ceph的底层RADOS（Reliable Autonomous Distributed Object Store），即属于这类对象存储。</p>

<p>而2006年以后，人们说到对象存储，往往指的是以AWS的S3为代表的，通过HTTP接口提供访问的存储服务或者存储系统。类似的系统还有Rackspace于2009年开始研发并于2010年开源的<a href="http://lib.csdn.net/base/openstack">OpenStack</a> <a href="http://lib.csdn.net/base/swift">Swift</a>（Rackspace的对象存储服务开始于2008年，但是<a href="http://lib.csdn.net/base/swift">swift</a>项目的开发是从2009年开始的，Rackspace用Swift项目对其云存储系统进行了彻底重构）。这里的“对象”（Object）和我们平时说的文件类似，如果我们把一个文件传到对象存储系统里面存起来，就叫做一个对象。</p>
</blockquote>

<p>从上面可以看到，对象存储的定义随着时间的发展是一直在改变的。从一种架构到代表一种存储形态。现在，对象存储已经是某种存储形态的代名词，而不再是指某种文件系统架构了，相应的文件系统架构也有了专有的名字比如分布式文件系统等等。</p>

<p>就操作粒度来说，文件系统可以比对象存储操作得更加细致。文件系统不局限于文件，通过特定的调用还可以操作块、inode等等。但是对象存储的最小粒度只是对象，最大粒度还是对象。随着计算机的发展，逻辑层次上的方便程度随着业务规模的扩大愈发重要。</p>

<blockquote>
<p>对象存储和文件系统在接口上的本质区别是对象存储不支持和<code>fread</code>和<code>fwrite</code>类似的随机位置读写操作，即一个文件PUT到对象存储里以后，如果要读取，只能GET整个文件，如果要修改一个对象，只能重新PUT一个新的到对象存储里，覆盖之前的对象或者形成一个新的版本。</p>

<p>如果结合平时使用云盘的经验，就不难理解这个特点了，用户会上传文件到云盘或者从云盘下载文件。如果要修改一个文件，会把文件下载下来，修改以后重新上传，替换之前的版本。实际上几乎所有的互联网应用，都是用这种存储方式读写数据的，比如<a href="http://lib.csdn.net/base/wechat">微信</a>，在朋友圈里发照片是上传图像、收取别人发的照片是下载图像，也可以从朋友圈中删除以前发送的内容；微博也是如此，通过微博API我们可以了解到，微博客户端的每一张图片都是通过REST风格的HTTP请求从服务端获取的，而我们要发微博的话，也是通过HTTP请求将数据包括图片传上去的。在没有对象存储以前，开发者需要自己为客户端提供HTTP的数据读写接口，并通过程序代码转换为对文件系统的读写操作。</p>
</blockquote>

<p>此外，对象存储拥有扁平化的数据结构。这个特点让它不用维护目录树，这在处理海量文件的时候会优势。对象存储K/V的存储的方式也能保证查找效率。</p>

<p>先这样吧。</p>
</article>
                <section class="author">
                    <div class="avatar" style="background-image: url(/images/avatar.jpg);"></div>
                    <a class="name" href="/about.me.html">钟俊</a>
                    <div class="intro">没有介绍</div>
                </section>
                <section class="recommend">
                    
                    <section class="nav prev more">
                        <div class="head">上篇文章</div>
                        <a class="link" href="/misc/2017/08/26/daqu-8-26.html">17-08-26 日报</a>
                    </section>
                    
                    
                    <section class="nav next more">
                        <div class="head">下篇文章</div>
                        <a class="link" href="/misc/2017/08/26/seaweedfs%e7%ae%80%e5%8d%95%e4%bb%8b%e7%bb%8d.html">seaweedfs简单介绍</a>
                    </section>
                    
                </section>
                
    <section id="disqus_thread"></section>
    <script type="text/javascript">
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//username.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>


            </article>
        </article>
        <footer class="footer">
    <span class="copyright">
        钟俊的博客 ©
        <script type="text/javascript">
            document.write(new Date().getFullYear());
        </script>
    </span>
    <span class="publish">Powered by <a href="http://www.chole.io/" target="_blank">Ink</a></span>
</footer>

        <script src="/bundle/index.js"></script>
    </body>
</html>
